// ==============================================
// üîó ABACUS LLM CLIENT - Client Abacus LLM Ultra Instinct
// ==============================================
// Version: 2.0.0 Ultra Instinct
// Auteur: Jarvis Expert
// Description: Client intelligent pour Abacus LLM avec gestion avanc√©e
// des requ√™tes, cache, retry et m√©triques de performance
// ==============================================

import { EventEmitter } from 'events';
import Logger from '../utils/logger.js';

/**
 * Client intelligent pour Abacus LLM
 */
export default class AbacusClient extends EventEmitter {
  constructor(config = {}) {
    super();
    
    this.config = {
      // Configuration Abacus
      apiKey: process.env.ABACUS_API_KEY || config.apiKey,
      baseUrl: 'https://routellm.abacus.ai/v1',
      model: 'route-llm', // Mod√®le par d√©faut
      
      // Configuration des requ√™tes
      maxRetries: 3,
      retryDelay: 1000,
      timeout: 30000,
      
      // Configuration du cache
      enableCache: true,
      cacheTtl: 5 * 60 * 1000, // 5 minutes
      
      // Configuration des m√©triques
      enableMetrics: true,
      maxMetricsHistory: 1000,
      
      // Configuration de la qualit√©
      qualityThreshold: 0.7,
      enableQualityCheck: true,
      
      ...config
    };
    
    this.logger = new Logger('AbacusClient');
    
    // Cache des r√©ponses
    this.cache = new Map();
    
    // M√©triques de performance
    this.metrics = {
      totalRequests: 0,
      successfulRequests: 0,
      failedRequests: 0,
      averageResponseTime: 0,
      averageQuality: 0,
      totalTokens: 0,
      cacheHits: 0,
      cacheMisses: 0
    };
    
    // Historique des requ√™tes
    this.requestHistory = [];
    
    this.isInitialized = false;
  }
  
  /**
   * Initialisation du client Abacus
   */
  async initialize() {
    try {
      this.logger.info('üîó Initialisation du client Abacus LLM...');
      
      // V√©rification de la cl√© API
      if (!this.config.apiKey) {
        throw new Error('Cl√© API Abacus manquante. D√©finissez ABACUS_API_KEY ou passez apiKey dans la config.');
      }
      
      // Test de connexion
      await this.testConnection();
      
      this.isInitialized = true;
      this.logger.info('‚úÖ Client Abacus LLM initialis√©');
      
      this.emit('initialized');
      
    } catch (error) {
      this.logger.error('‚ùå Erreur lors de l\'initialisation du client Abacus:', error);
      throw error;
    }
  }
  
  /**
   * Test de connexion √† l'API Abacus
   */
  async testConnection() {
    try {
      const response = await this.makeRequest({
        model: this.config.model,
        messages: [{ role: 'user', content: 'Test de connexion' }],
        max_tokens: 10
      });
      
      this.logger.debug('‚úÖ Connexion Abacus test√©e avec succ√®s');
      return response;
      
    } catch (error) {
      this.logger.error('‚ùå √âchec du test de connexion Abacus:', error);
      throw error;
    }
  }
  
  /**
   * G√©n√©ration de code avec Abacus LLM
   */
  async generateCode(prompt, options = {}) {
    const startTime = Date.now();
    
    try {
      this.logger.debug('üöÄ G√©n√©ration de code avec Abacus LLM...');
      
      const request = {
        type: 'code_generation',
        prompt,
        options: {
          model: options.model || this.config.model,
          max_tokens: options.maxTokens || 2000,
          temperature: options.temperature || 0.7,
          top_p: options.topP || 0.9,
          ...options
        },
        timestamp: Date.now()
      };
      
      // V√©rification du cache
      if (this.config.enableCache) {
        const cached = this.getCachedResponse(request);
        if (cached) {
          this.metrics.cacheHits++;
          this.logger.debug('üíæ R√©ponse trouv√©e dans le cache');
          return cached;
        }
      }
      
      // G√©n√©ration du prompt optimis√©
      const optimizedPrompt = this.optimizePromptForCodeGeneration(prompt, options);
      
      // Appel √† l'API Abacus
      const response = await this.makeRequest({
        model: request.options.model,
        messages: [
          {
            role: 'system',
            content: this.getSystemPrompt(options)
          },
          {
            role: 'user',
            content: optimizedPrompt
          }
        ],
        max_tokens: request.options.max_tokens,
        temperature: request.options.temperature,
        top_p: request.options.top_p
      });
      
      // Traitement de la r√©ponse
      const result = this.processCodeResponse(response, options);
      
      // Mise √† jour des m√©triques
      this.updateMetrics(startTime, true, result.quality);
      
      // Mise en cache
      if (this.config.enableCache) {
        this.cacheResponse(request, result);
      }
      
      // Enregistrement dans l'historique
      this.recordRequest(request, result, Date.now() - startTime);
      
      this.logger.debug(`‚úÖ Code g√©n√©r√© avec succ√®s en ${Date.now() - startTime}ms`);
      
      return result;
      
    } catch (error) {
      this.logger.error('‚ùå Erreur lors de la g√©n√©ration de code:', error);
      
      // Mise √† jour des m√©triques
      this.updateMetrics(startTime, false, 0);
      
      throw error;
    }
  }
  
  /**
   * G√©n√©ration de documentation avec Abacus LLM
   */
  async generateDocumentation(code, options = {}) {
    const startTime = Date.now();
    
    try {
      this.logger.debug('üìö G√©n√©ration de documentation avec Abacus LLM...');
      
      const prompt = `G√©n√®re une documentation compl√®te pour ce code:\n\n${code}`;
      
      const response = await this.makeRequest({
        model: options.model || this.config.model,
        messages: [
          {
            role: 'system',
            content: 'Tu es un expert en documentation de code. G√©n√®re une documentation claire et compl√®te.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        max_tokens: options.maxTokens || 1500,
        temperature: 0.3
      });
      
      const result = {
        type: 'documentation',
        content: response.choices[0].message.content,
        quality: this.assessQuality(response.choices[0].message.content),
        metadata: {
          model: options.model || this.config.model,
          tokens: response.usage?.total_tokens || 0,
          responseTime: Date.now() - startTime
        }
      };
      
      this.updateMetrics(startTime, true, result.quality);
      
      return result;
      
    } catch (error) {
      this.logger.error('‚ùå Erreur lors de la g√©n√©ration de documentation:', error);
      this.updateMetrics(startTime, false, 0);
      throw error;
    }
  }
  
  /**
   * Analyse de code avec Abacus LLM
   */
  async analyzeCode(code, options = {}) {
    const startTime = Date.now();
    
    try {
      this.logger.debug('üîç Analyse de code avec Abacus LLM...');
      
      const prompt = `Analyse ce code et fournis:\n1. Une √©valuation de la qualit√©\n2. Les probl√®mes potentiels\n3. Des suggestions d'am√©lioration\n\nCode:\n${code}`;
      
      const response = await this.makeRequest({
        model: options.model || this.config.model,
        messages: [
          {
            role: 'system',
            content: 'Tu es un expert en analyse de code. Fournis une analyse d√©taill√©e et constructive.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        max_tokens: options.maxTokens || 1000,
        temperature: 0.2
      });
      
      const result = {
        type: 'analysis',
        content: response.choices[0].message.content,
        quality: this.assessQuality(response.choices[0].message.content),
        metadata: {
          model: options.model || this.config.model,
          tokens: response.usage?.total_tokens || 0,
          responseTime: Date.now() - startTime
        }
      };
      
      this.updateMetrics(startTime, true, result.quality);
      
      return result;
      
    } catch (error) {
      this.logger.error('‚ùå Erreur lors de l\'analyse de code:', error);
      this.updateMetrics(startTime, false, 0);
      throw error;
    }
  }
  
  /**
   * G√©n√©ration de tests avec Abacus LLM
   */
  async generateTests(code, options = {}) {
    const startTime = Date.now();
    
    try {
      this.logger.debug('üß™ G√©n√©ration de tests avec Abacus LLM...');
      
      const prompt = `G√©n√®re des tests unitaires complets pour ce code:\n\n${code}`;
      
      const response = await this.makeRequest({
        model: options.model || this.config.model,
        messages: [
          {
            role: 'system',
            content: 'Tu es un expert en tests unitaires. G√©n√®re des tests complets et robustes.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        max_tokens: options.maxTokens || 2000,
        temperature: 0.4
      });
      
      const result = {
        type: 'tests',
        content: response.choices[0].message.content,
        quality: this.assessQuality(response.choices[0].message.content),
        metadata: {
          model: options.model || this.config.model,
          tokens: response.usage?.total_tokens || 0,
          responseTime: Date.now() - startTime
        }
      };
      
      this.updateMetrics(startTime, true, result.quality);
      
      return result;
      
    } catch (error) {
      this.logger.error('‚ùå Erreur lors de la g√©n√©ration de tests:', error);
      this.updateMetrics(startTime, false, 0);
      throw error;
    }
  }
  
  /**
   * Appel principal √† l'API Abacus
   */
  async makeRequest(requestData) {
    const url = `${this.config.baseUrl}/chat/completions`;
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.config.apiKey}`
      },
      body: JSON.stringify(requestData)
    });
    
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(`Erreur API Abacus: ${response.status} - ${errorData.error?.message || response.statusText}`);
    }
    
    return await response.json();
  }
  
  /**
   * Optimisation du prompt pour la g√©n√©ration de code
   */
  optimizePromptForCodeGeneration(prompt, options) {
    let optimizedPrompt = prompt;
    
    // Ajout de contexte selon le type de g√©n√©ration
    if (options.type === 'component') {
      optimizedPrompt = `Cr√©e un composant React moderne et bien structur√©:\n\n${prompt}`;
    } else if (options.type === 'hook') {
      optimizedPrompt = `Cr√©e un hook React personnalis√©:\n\n${prompt}`;
    } else if (options.type === 'page') {
      optimizedPrompt = `Cr√©e une page React compl√®te:\n\n${prompt}`;
    }
    
    // Ajout d'instructions de qualit√©
    optimizedPrompt += '\n\nInstructions:\n- Utilise TypeScript si possible\n- Ajoute des commentaires JSDoc\n- Suis les meilleures pratiques React\n- Code propre et lisible';
    
    return optimizedPrompt;
  }
  
  /**
   * Obtention du prompt syst√®me
   */
  getSystemPrompt(options) {
    const basePrompt = 'Tu es un expert d√©veloppeur React/TypeScript. Tu g√©n√®res du code de haute qualit√©, bien structur√© et suivant les meilleures pratiques.';
    
    if (options.type === 'component') {
      return `${basePrompt} Tu te sp√©cialises dans la cr√©ation de composants React r√©utilisables et performants.`;
    } else if (options.type === 'hook') {
      return `${basePrompt} Tu te sp√©cialises dans la cr√©ation de hooks React personnalis√©s.`;
    } else if (options.type === 'page') {
      return `${basePrompt} Tu te sp√©cialises dans la cr√©ation de pages React compl√®tes.`;
    }
    
    return basePrompt;
  }
  
  /**
   * Traitement de la r√©ponse de g√©n√©ration de code
   */
  processCodeResponse(response, options) {
    const content = response.choices[0].message.content;
    
    // Extraction du code (suppression des markdown si pr√©sent)
    const codeMatch = content.match(/```(?:javascript|typescript|jsx|tsx)?\n([\s\S]*?)\n```/);
    const code = codeMatch ? codeMatch[1] : content;
    
    // √âvaluation de la qualit√©
    const quality = this.assessCodeQuality(code, options);
    
    return {
      type: 'code_generation',
      content: code,
      originalResponse: content,
      quality,
      metadata: {
        model: options.model || this.config.model,
        tokens: response.usage?.total_tokens || 0,
        finishReason: response.choices[0].finish_reason
      }
    };
  }
  
  /**
   * √âvaluation de la qualit√© du code g√©n√©r√©
   */
  assessCodeQuality(code, options) {
    let quality = 0.5; // Base
    
    // V√©rification de la syntaxe basique
    if (code.includes('export') || code.includes('function') || code.includes('const')) {
      quality += 0.2;
    }
    
    // V√©rification des bonnes pratiques React
    if (code.includes('useState') || code.includes('useEffect')) {
      quality += 0.1;
    }
    
    if (code.includes('className') || code.includes('onClick')) {
      quality += 0.1;
    }
    
    // V√©rification TypeScript
    if (options.typescript && (code.includes(': string') || code.includes(': number') || code.includes('interface'))) {
      quality += 0.1;
    }
    
    // V√©rification de la longueur (ni trop court ni trop long)
    const lines = code.split('\n').length;
    if (lines >= 5 && lines <= 50) {
      quality += 0.1;
    }
    
    return Math.min(1.0, quality);
  }
  
  /**
   * √âvaluation de la qualit√© g√©n√©rale
   */
  assessQuality(content) {
    let quality = 0.5; // Base
    
    // Longueur du contenu
    if (content.length > 100) quality += 0.1;
    if (content.length > 500) quality += 0.1;
    
    // Structure (pr√©sence de listes, sections, etc.)
    if (content.includes('\n-') || content.includes('\n1.') || content.includes('##')) {
      quality += 0.1;
    }
    
    // Pr√©sence de code
    if (content.includes('```') || content.includes('function') || content.includes('const')) {
      quality += 0.1;
    }
    
    return Math.min(1.0, quality);
  }
  
  /**
   * Gestion du cache
   */
  getCachedResponse(request) {
    const cacheKey = this.generateCacheKey(request);
    const cached = this.cache.get(cacheKey);
    
    if (cached && Date.now() - cached.timestamp < this.config.cacheTtl) {
      return cached.data;
    }
    
    if (cached) {
      this.cache.delete(cacheKey);
    }
    
    this.metrics.cacheMisses++;
    return null;
  }
  
  /**
   * Mise en cache d'une r√©ponse
   */
  cacheResponse(request, response) {
    const cacheKey = this.generateCacheKey(request);
    this.cache.set(cacheKey, {
      data: response,
      timestamp: Date.now()
    });
  }
  
  /**
   * G√©n√©ration d'une cl√© de cache
   */
  generateCacheKey(request) {
    return `${request.type}_${request.prompt.substring(0, 100)}_${JSON.stringify(request.options)}`;
  }
  
  /**
   * Mise √† jour des m√©triques
   */
  updateMetrics(startTime, success, quality) {
    const responseTime = Date.now() - startTime;
    
    this.metrics.totalRequests++;
    
    if (success) {
      this.metrics.successfulRequests++;
    } else {
      this.metrics.failedRequests++;
    }
    
    // Mise √† jour de la moyenne des temps de r√©ponse
    const totalTime = this.metrics.averageResponseTime * (this.metrics.totalRequests - 1) + responseTime;
    this.metrics.averageResponseTime = totalTime / this.metrics.totalRequests;
    
    // Mise √† jour de la qualit√© moyenne
    if (success) {
      const totalQuality = this.metrics.averageQuality * (this.metrics.successfulRequests - 1) + quality;
      this.metrics.averageQuality = totalQuality / this.metrics.successfulRequests;
    }
  }
  
  /**
   * Enregistrement d'une requ√™te dans l'historique
   */
  recordRequest(request, response, responseTime) {
    this.requestHistory.push({
      request,
      response,
      responseTime,
      timestamp: Date.now()
    });
    
    // Limitation de l'historique
    if (this.requestHistory.length > this.config.maxMetricsHistory) {
      this.requestHistory = this.requestHistory.slice(-this.config.maxMetricsHistory);
    }
  }
  
  /**
   * Obtention des m√©triques
   */
  getMetrics() {
    return {
      ...this.metrics,
      cacheHitRate: this.metrics.cacheHits / (this.metrics.cacheHits + this.metrics.cacheMisses) || 0,
      successRate: this.metrics.successfulRequests / this.metrics.totalRequests || 0
    };
  }
  
  /**
   * Obtention de l'historique des requ√™tes
   */
  getRequestHistory(limit = 10) {
    return this.requestHistory
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(0, limit);
  }
  
  /**
   * Nettoyage du cache
   */
  clearCache() {
    this.cache.clear();
    this.logger.info('üßπ Cache Abacus nettoy√©');
  }
  
  /**
   * R√©initialisation des m√©triques
   */
  resetMetrics() {
    this.metrics = {
      totalRequests: 0,
      successfulRequests: 0,
      failedRequests: 0,
      averageResponseTime: 0,
      averageQuality: 0,
      totalTokens: 0,
      cacheHits: 0,
      cacheMisses: 0
    };
    
    this.requestHistory = [];
    this.logger.info('üîÑ M√©triques Abacus r√©initialis√©es');
  }
  
  /**
   * Fermeture du client
   */
  async close() {
    this.logger.info('üîÑ Fermeture du client Abacus LLM...');
    this.emit('closed');
  }
}
