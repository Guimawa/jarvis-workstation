#!/usr/bin/env node

import { createRequire } from 'module';
const require = createRequire(import.meta.url);

import fs from 'fs/promises';
import path from 'path';
import inquirer from 'inquirer';
import chalk from 'chalk';
import figlet from 'figlet';
import { spawn } from 'child_process';
import { fileURLToPath } from 'url';

// Charger les variables d'environnement
require('dotenv').config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Imports locaux
import { getGroqClient } from './src/utils/groq-client.js';
import CodeValidator from './src/utils/validators.js';
import CodeFormatter from './src/utils/formatters.js';

// Configuration
const CONFIG = {
    srcPath: './src',
    logFile: './generation-log.json',
    maxFileSize: process.env.MAX_FILE_SIZE || 10000,
    cacheTTL: process.env.CACHE_TTL || 300000
};

class DashboardCLI {
    constructor() {
        this.generationCount = 0;
        this.sessionId = this.generateSessionId();
        this.init();
    }

    /**
     * Initialize the CLI application
     */
    async init() {
        try {
            await this.clearScreen();
            await this.showWelcome();
            await this.checkEnvironment();
            await this.mainMenu();
        } catch (error) {
            this.handleFatalError(error);
        }
    }

    /**
     * Generate unique session ID
     */
    generateSessionId() {
        return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * Clear terminal screen
     */
    async clearScreen() {
        console.clear();
        if (process.platform === 'win32') {
            spawn('cmd', ['/c', 'cls']);
        } else {
            process.stdout.write('\x1B[2J\x1B[3J\x1B[H');
        }
    }

    /**
     * Show welcome banner
     */
    async showWelcome() {
        console.log(chalk.blueBright(
            figlet.textSync('IA COPILOT', { font: 'Slant' })
        ));
        
        console.log(chalk.greenBright('üöÄ Dashboard IA - G√©n√©ration de code assist√©e\n'));
        console.log(chalk.gray(`Session: ${this.sessionId}`));
        console.log(chalk.gray('‚îÅ'.repeat(50)));
    }

    /**
     * Check environment requirements
     */
    async checkEnvironment() {
        const checks = [
            {
                name: 'Dossier src/',
                check: async () => {
                    try {
                        await fs.access(CONFIG.srcPath);
                        return true;
                    } catch {
                        await fs.mkdir(CONFIG.srcPath, { recursive: true });
                        return true;
                    }
                }
            },
            {
                name: 'Cl√© API Groq',
                check: () => {
                    return !!process.env.GROQ_API_KEY;
                }
            }
        ];

        for (const check of checks) {
            const result = await check.check();
            if (!result) {
                throw new Error(`‚ùå √âchec v√©rification: ${check.name}`);
            }
        }
    }

    /**
     * Main interactive menu
     */
    async mainMenu() {
        while (true) {
            const { action } = await inquirer.prompt([
                {
                    type: 'list',
                    name: 'action',
                    message: 'üéØ Que veux-tu g√©n√©rer ?',
                    choices: [
                        { name: 'üìä Mod√®le de donn√©es MongoDB', value: 'model' },
                        { name: '‚öõÔ∏è Composant React', value: 'component' },
                        { name: 'üîå Service API', value: 'service' },
                        { name: 'üé® Hook personnalis√©', value: 'hook' },
                        { name: 'üìù Utilitaire/Helper', value: 'utility' },
                        { name: '‚öôÔ∏è Configuration', value: 'config' },
                        { name: 'üìä Stats de g√©n√©ration', value: 'stats' },
                        { name: 'üßπ Nettoyer le dossier src/', value: 'clean' },
                        { name: 'üö™ Quitter', value: 'exit' }
                    ],
                    pageSize: 10
                }
            ]);

            if (action === 'exit') {
                await this.exitApp();
                break;
            }

            await this.handleAction(action);
        }
    }

    /**
     * Handle menu actions
     */
    async handleAction(action) {
        switch (action) {
            case 'model':
                await this.generateCode('model', 'Mod√®le MongoDB');
                break;
            case 'component':
                await this.generateCode('component', 'Composant React');
                break;
            case 'service':
                await this.generateCode('service', 'Service API');
                break;
            case 'hook':
                await this.generateCode('hook', 'Hook React personnalis√©');
                break;
            case 'utility':
                await this.generateCode('utility', 'Utilitaire JavaScript');
                break;
            case 'config':
                await this.showConfig();
                break;
            case 'stats':
                await this.showStats();
                break;
            case 'clean':
                await this.cleanSourceFolder();
                break;
        }
    }

    /**
     * Generate code based on type
     */
    async generateCode(type, displayName) {
        try {
            const { name } = await inquirer.prompt([
                {
                    type: 'input',
                    name: 'name',
                    message: `üìù Nom du ${displayName.toLowerCase()} :`,
                    validate: (input) => {
                        if (!input.trim()) return 'Le nom ne peut pas √™tre vide';
                        if (!/^[a-zA-Z0-9_-]+$/.test(input)) {
                            return 'Utilise seulement lettres, chiffres, underscores et tirets';
                        }
                        return true;
                    }
                }
            ]);

            const prompt = await this.buildPrompt(type, name);
            console.log(chalk.blueBright('\n‚ö° G√©n√©ration en cours...'));

            const result = await groqClient.generateCode(
                prompt,
                `${displayName} ${name}`,
                2
            );

            if (result.success) {
                // üî• NOUVEAU : Validation et formatage
                console.log(chalk.blueBright('üîç Validation du code...'));
                
                // Validation
                const validationResult = await validator.validateCode(result.code);
                if (!validationResult.valid) {
                    console.log(chalk.yellow('‚ö†Ô∏è  Avertissements de validation:'));
                    validationResult.issues.forEach(issue => {
                        console.log(chalk.gray(`  - ${issue.message}`));
                    });
                }

                // Formatage
                console.log(chalk.blueBright('üé® Formatage du code...'));
                const formatResult = await formatter.formatCode(result.code);
                if (formatResult.success) {
                    result.code = formatResult.code;
                    console.log(chalk.gray(`‚úÖ Format√© avec ${formatResult.tool}`));
                } else {
                    console.log(chalk.yellow('‚ö†Ô∏è  √âchec du formatage, utilisation du code brut'));
                }

                await this.writeGeneratedFile(type, name, result);
                await this.logGeneration(result, true);
                
                // Afficher les m√©triques
                if (validationResult.metrics) {
                    console.log(chalk.gray(`üìä Complexit√©: ${validationResult.metrics.complexityScore}/100`));
                    console.log(chalk.gray(`üìè Lignes: ${validationResult.metrics.totalLines}`));
                }
                
                console.log(chalk.greenBright(`‚úÖ ${displayName} g√©n√©r√© avec succ√®s !`));
                
            } else {
                await this.logGeneration(result, false);
                console.log(chalk.redBright(`‚ùå Erreur: ${result.error}`));
            }

        } catch (error) {
            console.log(chalk.redBright(`‚ùå Erreur: ${error.message}`));
        }

        await this.pause();
    }

    /**
     * Build prompt based on type
     */
    async buildPrompt(type, name) {
        const prompts = {
            model: `G√©n√®re un mod√®le MongoDB Mongoose pour "${name}" avec validation, hooks et m√©thodes statiques si n√©cessaire.`,
            component: `Cr√©e un composant React fonctionnel "${name}" avec TypeScript, hooks modernes et props typ√©es.`,
            service: `D√©veloppe un service API "${name}" avec gestion d'erreurs, intercepteurs et m√©thodes CRUD compl√®tes.`,
            hook: `√âcris un hook React personnalis√© "${name}" avec gestion d'√©tat, effets et retour typ√©.`,
            utility: `Cr√©e une utilitaire "${name}" avec fonctions pures, tests unitaires et documentation JSDoc.`
        };

        return prompts[type] || `G√©n√®re du code pour ${name}`;
    }

    /**
     * Write generated file to appropriate location
     */
    async writeGeneratedFile(type, name, result) {
        const extensions = {
            model: '.js',
            component: '.tsx',
            service: '.ts',
            hook: '.ts',
            utility: '.ts'
        };

        const directories = {
            model: 'models',
            component: 'components',
            service: 'services',
            hook: 'hooks',
            utility: 'utils'
        };

        const dirPath = path.join(CONFIG.srcPath, directories[type]);
        await fs.mkdir(dirPath, { recursive: true });

        const fileName = `${name}${extensions[type]}`;
        const filePath = path.join(dirPath, fileName);

        // V√©rifier la taille du fichier
        if (result.code.length > CONFIG.maxFileSize) {
            throw new Error(`Fichier trop volumineux (${result.code.length} caract√®res)`);
        }

        await fs.writeFile(filePath, result.code, 'utf-8');
        console.log(chalk.gray(`üìÅ Fichier cr√©√©: ${filePath}`));
    }

    /**
     * Log generation results
     */
    async logGeneration(result, success) {
        const logEntry = {
            sessionId: this.sessionId,
            timestamp: new Date().toISOString(),
            success,
            model: result.model,
            metadata: result.metadata,
            error: result.error,
            attempts: result.attempts
        };

        this.generationCount++;

        try {
            let logs = [];
            try {
                const data = await fs.readFile(CONFIG.logFile, 'utf-8');
                logs = JSON.parse(data);
            } catch {
                logs = [];
            }

            logs.push(logEntry);
            await fs.writeFile(CONFIG.logFile, JSON.stringify(logs, null, 2));
        } catch (error) {
            console.warn('‚ö†Ô∏è Impossible d\'√©crire dans le log');
        }
    }

    /**
     * Show configuration
     */
    async showConfig() {
        console.log('\n‚öôÔ∏è  Configuration actuelle:');
        console.log(chalk.gray('‚îÅ'.repeat(30)));
        console.log(`Mod√®le Groq: ${chalk.cyan(groqClient.model)}`);
        console.log(`Dossier source: ${chalk.cyan(CONFIG.srcPath)}`);
        console.log(`Cl√© API: ${chalk.cyan(process.env.GROQ_API_KEY ? '‚úÖ D√©finie' : '‚ùå Manquante')}`);
        console.log(`Session: ${chalk.cyan(this.sessionId)}`);
        console.log(chalk.gray('‚îÅ'.repeat(30)));
        await this.pause();
    }

    /**
     * Show generation statistics
     */
    async showStats() {
        try {
            const data = await fs.readFile(CONFIG.logFile, 'utf-8');
            const logs = JSON.parse(data);
            
            const successCount = logs.filter(log => log.success).length;
            const totalCount = logs.length;

            console.log('\nüìä Statistiques de g√©n√©ration:');
            console.log(chalk.gray('‚îÅ'.repeat(40)));
            console.log(`Total g√©n√©rations: ${chalk.cyan(totalCount)}`);
            console.log(`Succ√®s: ${chalk.green(successCount)}`);
            console.log(`√âchecs: ${chalk.red(totalCount - successCount)}`);
            console.log(`Taux de succ√®s: ${chalk.cyan(((successCount / totalCount) * 100).toFixed(1))}%`);

            if (logs.length > 0) {
                const lastGen = logs[logs.length - 1];
                console.log(`Dernier mod√®le utilis√©: ${chalk.cyan(lastGen.model)}`);
            }

        } catch {
            console.log('\nüìä Aucune donn√©e statistique disponible');
        }

        await this.pause();
    }

    /**
     * Clean source folder
     */
    async cleanSourceFolder() {
        const { confirm } = await inquirer.prompt([
            {
                type: 'confirm',
                name: 'confirm',
                message: '‚ö†Ô∏è  Es-tu s√ªr de vouloir vider le dossier src/?',
                default: false
            }
        ]);

        if (confirm) {
            try {
                await fs.rm(CONFIG.srcPath, { recursive: true, force: true });
                await fs.mkdir(CONFIG.srcPath, { recursive: true });
                console.log(chalk.green('‚úÖ Dossier src/ nettoy√© avec succ√®s'));
            } catch (error) {
                console.log(chalk.red('‚ùå Erreur lors du nettoyage'));
            }
        }

        await this.pause();
    }
    /**
     * Attend que l'utilisateur appuie sur Entr√©e
     */
    async pause() {
        console.log('\n');
        await inquirer.prompt([
            {
                type: 'input',
                name: 'continue',
                message: 'Appuyez sur Entr√©e pour continuer...'
            }
        ]);
    }
    /**
     * G√®re les erreurs fatales
     */
    handleFatalError(error) {
        console.error(chalk.redBright(`\nüí• ERREUR FATALE: ${error.message}`));
        console.error(chalk.gray(error.stack));
        process.exit(1);
    }
    /**
     * Quitte l'application proprement
     */
    async exitApp() {
        console.log(chalk.blueBright('\nüëã Merci d\'avoir utilis√© le Dashboard IA !'));
        console.log(chalk.gray(`G√©n√©rations cette session: ${this.generationCount}`));
        await new Promise(resolve => setTimeout(resolve, 1000));
        process.exit(0);
    }
}
// Handle uncaught errors
process.on('uncaughtException', (error) => {
    console.error(chalk.redBright('\nüí• ERREUR NON G√âR√âE:'), error.message);
    process.exit(1);
});
process.on('unhandledRejection', (reason, promise) => {
    console.error(chalk.redBright('\nüí• PROMESSE REJET√âE:'), reason);
    process.exit(1);
});
// Start the application
new DashboardCLI();